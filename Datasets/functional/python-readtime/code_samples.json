[
  {
    "id": 1,
    "desription": "function description: of_text(text, wpm): calculate the reading time of a given text. of_html(html, wpm): calculate the reading time of an HTML document. of_markdown(markdown, wpm): calculate the reading time of a markdown text. class Result(seconds, wpm): initialize the model structure and parameters. seconds(): returns the total number of seconds in the delta. minutes(): calculates the estimated reading time in minutes. text(): get the text representation of the read time. _add_operator_methods(): adds operator methods to the class dynamically. _create_method(op): create a method for the Result class based on the given operation. read_time(content, format, wpm): calculate the estimated reading time for the given content. read_time_as_seconds(text, images, wpm): calculate the estimated reading time in seconds for a given text. parse_html(el): parse an HTML element and extract text and image information.",
    "in_point": "any function",
    "out_point": "any function",
    "full_code": "\nimport math\nimport re\nimport lxml\nimport markdown2\nfrom pyquery import PyQuery as pq\nimport operator\nfrom datetime import timedelta\n\nDEFAULT_WPM = 265\nWORD_DELIMITER = re.compile(r'\\W+')\n\nclass Result:\n    delta = None\n\n    def __init__(self, seconds=None, wpm=None):\n        self.wpm = wpm\n        self.delta = timedelta(seconds=seconds)\n        self._add_operator_methods()\n\n    def __repr__(self):\n        return self.text + ' read'\n\n    def __str__(self):\n        return self.__repr__()\n\n    @property\n    def seconds(self):\n        return int(self.delta.total_seconds())\n\n    @property\n    def minutes(self):\n        minutes = math.ceil(self.seconds / 60)\n        minutes = max(1, minutes)\n        return minutes\n\n    @property\n    def text(self):\n        return f'{self.minutes} min'\n\n    def _add_operator_methods(self):\n        for op in dir(operator):\n            can_set = (getattr(self.__class__, op, None) is None and\n                        getattr(self.delta, op, None) is not None and\n                        op.startswith('__') and\n                        op.endswith('__'))\n            if can_set:\n                try:\n                    setattr(self.__class__, op, self._create_method(op))\n                except (AttributeError, TypeError):\n                    pass\n\n    def _create_method(self, op):\n        fn = getattr(self.delta, op)\n\n        def method(cls, other, *args, **kwargs):\n            delta = fn(other.delta)\n            return Result(seconds=delta.total_seconds(), wpm=self.wpm)\n\n        return method\n\ndef read_time(content, format=None, wpm=265):\n    try:\n        format = format.lower()\n    except:\n        pass\n\n    if format == 'text':\n        seconds = read_time_as_seconds(content, wpm=wpm)\n\n    elif format == 'markdown':\n        html = markdown2.markdown(content)\n        el = pq(html)\n        text, images = parse_html(el)\n        seconds = read_time_as_seconds(text, images=images, wpm=wpm)\n\n    elif format == 'html':\n        el = pq(content)\n        text, images = parse_html(el)\n        seconds = read_time_as_seconds(text, images=images, wpm=wpm)\n\n    else:\n        raise Exception(f'Unsupported format: {format}')\n\n    return Result(seconds=seconds, wpm=wpm)\n\n\ndef read_time_as_seconds(text, images=0, wpm=265):\n    try:\n        num_words = len(re.split(WORD_DELIMITER, text.strip()))\n    except (AttributeError, TypeError):\n        num_words = 0\n\n    seconds = math.ceil(num_words / wpm * 60)\n\n    delta = 12\n    for _ in range(images):\n        seconds += delta\n        if delta > 3:\n            delta -= 1\n\n    return seconds\n\n\ndef parse_html(el):\n    text = []\n    images = []\n    paragraphs = ['h1', 'h2', 'h3', 'h4', 'h5']\n\n    def add_text(tag, no_tail=False):\n        if tag.tag == 'img':\n            images.append(tag)\n        if tag.text and not isinstance(tag, lxml.etree._Comment):\n            text.append(tag.text)\n        for child in tag.getchildren():\n            add_text(child)\n        if tag.tag in paragraphs and len(text) > 0 and not text[-1].strip().endswith('.'):\n            text.append('.')\n        if not no_tail and tag.tail:\n            text.append(tag.tail)\n\n    for tag in el:\n        add_text(tag, no_tail=True)\n\n    plain_text = re.sub(r'\\s+', ' ', ''.join([t for t in text if t])).strip()\n\n    return plain_text, len(images)\n\ndef of_text(text, wpm=265):\n\n    return read_time(text, format='text', wpm=wpm)\n\n\ndef of_html(html, wpm=265):\n\n    return read_time(html, format='html', wpm=wpm)\n\n\ndef of_markdown(markdown, wpm=265):\n\n    return read_time(markdown, format='markdown', wpm=wpm)\n"
  }
]